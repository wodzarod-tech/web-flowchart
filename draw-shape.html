<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Shape Drawer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
	--toolbar-h:60px;
	--panel-w:340px;
  }
  
  body {
	margin:0;
	font-family:system-ui,Segoe UI,Roboto,Arial;
	user-select:none;
	-webkit-user-select:none;
  }
  
  #toolbar {
    height:var(--toolbar-h);
    display:flex;
    gap:10px;
    align-items:center;
    padding:8px;
    background:#f4f4f4;
    box-sizing:border-box;
  }
  
  #toolbar > * { font-size:14px; }
  
  canvas {
	display:block;
	width:100vw;
	height:calc(100vh - var(--toolbar-h));
	background:#fff; cursor:crosshair;
  }
  
  button {
	padding:6px 10px;
	border-radius:6px;
	border:1px solid #bbb;
	background:#fff;
	cursor:pointer;
  }
  
  input[type="number"] { width:80px; }
  
  label {
	display:flex;
	align-items:center;
	gap:6px;
  }

  /* Slide-in panel (Option C) */
  #panel {
    position: fixed;
    right: 0;
    top: 0;
    width: var(--panel-w);
    height: 100vh;
    background: #ffffff;
    border-left: 1px solid #e3e3e3;
    box-shadow: -18px 0 40px rgba(10,10,10,0.06);
    transform: translateX(100%); /* animation */
    transition: transform 280ms cubic-bezier(.2,.8,.2,1); /* animation */
    z-index: 120;
    padding: 16px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  #panel.open { 
    transform: translateX(0); /* animation */
  }

  #panel header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
  }
  
  #panel h3 { 
	margin:0;
	font-size:16px
  }
  
  #panel .row {
	display:flex;
	gap:8px;
	align-items:center;
	margin-top:6px;
  }
  
  #panel label {
	width:120px;
	font-size:13px;
	color:#333;
  }
  
  #panel input[type="text"], #panel input[type="number"], #panel select {
    width: calc(100% - 120px);
    padding:6px 8px;
    border:1px solid #ddd;
    border-radius:6px;
    font-size:13px;
  }
  
  #panel input[type="color"] { 
	width:48px;
	height:32px;
	padding:0;
	border:0;
	background:transparent;
  }
  
  #panel .footer {
	margin-top:auto; /* pushes footer to bottom */
	display:flex;
	justify-content: flex-end;   /* pushes content to the right */
	gap:8px;
  }
  
  .muted { 
	color:#666;
	font-size:12px;
  }

  @media (max-width: 900px) { :root { --panel-w: 300px; } }
  
  #textEditor {
    background: transparent;
    outline: none;
    border: none;
	text-align: center;
	padding-top: 30%;
  }
  
  .label-line {
    display: inline-block;
	padding-bottom: 4px;
	border-bottom: 2px solid #000;
	font-weight: bold;
  }
</style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- for insert text into a shape -->
  <textarea id="textEditor"
		    style="position:absolute; display:none; resize:none;
				   padding:4px; font-size:16px; 
				   border:1px solid #333; outline:none;">
  </textarea>

  <!-- Slide-in Panel for Shape Properties -->
  <div id="panel" aria-hidden="true">
	
	<!-- first panel -->
	<div id="toolbar">
	  <label>Shape:
		<select id="shapeType">
		  <option value="rectangle">Rectangle</option>
		  <option value="circle">Circle</option>
		</select>
	  </label>

	  <button id="clearBtn">Clear</button>
	  <button id="deleteBtn">Delete Selected</button>
	</div>

    <header>
      <h3>Shape Properties</h3>
      <div>
        <button id="panelClose" title="Close">✕</button>
      </div>
    </header>

    <div class="row">
  	  <label class="label-line">Shape</label>
    </div>

    <div class="row">
      <label>Type</label>
        <select id="propType" disabled>
          <option value="rectangle">Rectangle</option>
          <option value="circle">Circle</option>
        </select>
    </div>

    <div class="row">
      <label>Fill</label>
      <input id="propFill" type="color">
    </div>

    <div class="row">
      <label>Border</label>
      <select id="propBorder">
        <option value="solid">Solid</option>
        <option value="dashed">Dashed</option>
        <option value="bold">Bold</option>
      </select>
    </div>

    <div class="row">
      <label>Thickness</label>
      <input id="propThickness" type="number" min="1" max="20" step="1">
    </div>

    <div class="row">
      <label>Opacity</label>
      <input id="propOpacity" type="range" min="0" max="1" step="0.05">
      <span id="propOpacityVal" class="muted" style="min-width:40px;text-align:right;"></span>
    </div>

    <div class="row">
      <label>Rounded</label>
      <input id="propRounded" type="checkbox" title="Rectangle rounded">
    </div>

    <div class="row">
      <label>X</label>
      <input id="propX" type="number" step="1">
    </div>

    <div class="row">
      <label>Y</label>
      <input id="propY" type="number" step="1">
    </div>

    <div class="row" id="sizeRow">
      <label>W</label>
      <input id="propW" type="number" step="1">
    </div>

    <div class="row" id="sizeRowH">
      <label>H / R</label>
      <input id="propH" type="number" step="1">
    </div>

    <div class="row">
    	<label class="label-line">Text</label>
    </div>
  
    <div class="row">
      <label>Text</label>
      <input id="panelText" type="text" placeholder="shape text">
    </div>

    <div class="row">
      <label>Font size</label>
      <input id="panelTextSize" type="number" min="8" max="72" value="16">
    </div>

    <div class="row">
      <label>Text color</label>
      <input id="panelTextColor" type="color" value="#000000">
    </div>

    <div class="row">
      <label>Text Position:</label>
	  <select id="textPosition">
	    <option value="center">Center</option>
	    <option value="top">Top</option>
	    <option value="bottom">Bottom</option>
	    <option value="left">Left</option>
	    <option value="right">Right</option>
	  </select>
    </div>

    <div class="footer">
      <button id="propApply">Apply</button>
      <button id="propReset">Reset</button>
    </div>
  </div>

<script>
/* -------------------- Setup & State -------------------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const toolbar = document.getElementById('toolbar');
const shapeType = document.getElementById('shapeType');

const clearBtn = document.getElementById('clearBtn');
const deleteBtn = document.getElementById('deleteBtn');

const panel = document.getElementById('panel');
const panelClose = document.getElementById('panelClose');
const propType = document.getElementById('propType');
const propFill = document.getElementById('propFill');
const propBorder = document.getElementById('propBorder');
const propThickness = document.getElementById('propThickness');
const propOpacity = document.getElementById('propOpacity');
const propOpacityVal = document.getElementById('propOpacityVal');
const propRounded = document.getElementById('propRounded');
const propX = document.getElementById('propX');
const propY = document.getElementById('propY');
const propW = document.getElementById('propW');
const propH = document.getElementById('propH');
const propApply = document.getElementById('propApply');
const propReset = document.getElementById('propReset');

const panelText = document.getElementById('panelText');
const panelTextSize = document.getElementById('panelTextSize');
const panelTextColor = document.getElementById('panelTextColor');

const textEditor = document.getElementById("textEditor");

// main variables
let shapes = [];         // list of drawn shapes
let selected = null;     // shape currently selected
let tempShape = null;    // shape preview while drawing

// interaction flags
let isDrawing = false;
let isDragging = false;
let isResizing = false;

let activeHandle = null;

// pointer start
let startX = 0, startY = 0;
let dragOffsetX = 0, dragOffsetY = 0;

let editingShape = null;

/* -------------------- Canvas size -------------------- */
function setCanvasSizeCSS() {
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = (window.innerHeight - toolbar.offsetHeight) + 'px';
  fitCanvas();
}

// Canvas Auto-scaling
function fitCanvas() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  redraw();
}

window.addEventListener('resize', setCanvasSizeCSS);
setCanvasSizeCSS();

// initial redraw
redraw();

/* -------------------- Shape Class -------------------- */
/*
1. each shape stores:
Type: "rectangle" or "circle"
Position: x, y
Dimensions: w, h
Rounded corners (rectangle only)
Fill, stroke, opacity
Text & text style

2. methods:
draw(): draws shape on canvas
drawOutline(): red dashed selection outline
drawHandles(): corner handles for resizing
contains(px,py): check if clicked
handleAt(px,py): check if touching a handle
*/
class Shape {
  constructor(type, x, y, w, h, opts = {}) {
    this.type = type;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.rounded = !!opts.rounded;
    this.radius = (this.rounded && type === 'rectangle') ? Math.max(0, Math.min(Math.abs(w), Math.abs(h)) * 0.1) : 0;

    this.opts = {
      border: opts.border || 'solid',
      fill: opts.fill || '#ffffff',
      thickness: opts.thickness || 2,
      opacity: typeof opts.opacity === 'number' ? opts.opacity : 1
    };

    // Text properties
    this.text = opts.text || "";
    this.textSize = opts.textSize || 16;
    this.textColor = opts.textColor || "#000000";
	this.textPosition = opts.textPosition || "center"; 
  }

  draw(ctx, highlight=false) {
    ctx.save();
    ctx.globalAlpha = this.opts.opacity;
    ctx.fillStyle = this.opts.fill;
    ctx.strokeStyle = 'black';
    ctx.lineWidth = this.opts.border === 'bold' ? this.opts.thickness * 3 : this.opts.thickness;
    ctx.setLineDash(this.opts.border === 'dashed' ? [6,4] : []);

    if (this.type === 'rectangle') {
      drawRoundedOrPlainRect(ctx, this.x, this.y, this.w, this.h, this.rounded ? this.radius : 0);
    } else { // circle
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      ctx.beginPath();
      ctx.arc(this.x, this.y, r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }

    if (highlight) {
      this.drawOutline(ctx);
      this.drawHandles(ctx);
    }
    ctx.restore();
  }

  drawOutline(ctx) {
    ctx.save();
    ctx.setLineDash([4,4]);
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    if (this.type === 'rectangle') {
      ctx.strokeRect(this.x - 6, this.y - 6, this.w + 12, this.h + 12);
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      ctx.beginPath();
      ctx.arc(this.x, this.y, r + 6, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  getHandles() {
    if (this.type === 'rectangle') {
      return [
        {name:'tl', x:this.x, y:this.y},
        {name:'tr', x:this.x + this.w, y:this.y},
        {name:'bl', x:this.x, y:this.y + this.h},
        {name:'br', x:this.x + this.w, y:this.y + this.h},
      ];
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      return [
        {name:'tl', x:this.x - r, y:this.y - r},
        {name:'tr', x:this.x + r, y:this.y - r},
        {name:'bl', x:this.x - r, y:this.y + r},
        {name:'br', x:this.x + r, y:this.y + r},
      ];
    }
  }

  drawHandles(ctx) {
    const hs = this.getHandles();
    ctx.save();
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    hs.forEach(h => {
      ctx.beginPath();
      ctx.rect(h.x - 6, h.y - 6, 12, 12);
      ctx.fill();
      ctx.stroke();
    });
    ctx.restore();
  }

  contains(px,py) {
    if (this.type === 'rectangle') {
      const x0 = Math.min(this.x, this.x + this.w);
      const x1 = Math.max(this.x, this.x + this.w);
      const y0 = Math.min(this.y, this.y + this.h);
      const y1 = Math.max(this.y, this.y + this.h);
      return px >= x0 && px <= x1 && py >= y0 && py <= y1;
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      const dx = px - this.x;
      const dy = py - this.y;
      return dx*dx + dy*dy <= r*r;
    }
  }

  handleAt(px,py) {
    const hs = this.getHandles();
    for (const h of hs) {
      if (px >= h.x - 6 && px <= h.x + 6 && py >= h.y - 6 && py <= h.y + 6) return h.name;
    }
    return null;
  }
}

/* -------------------- Panel Control -------------------- */
/*
used when selecting a shape

Panel fields are updated with:
	fill color
	border style
	opacity
	text fields
	x/y/w/h
*/
function openPanelForShape(shape) {
  if (!shape) return;
  
  selected = shape;

  syncPanelToShape();
  
  // show toolbar text controls if shape has text (we show them always when selected)
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
  
  // ensure panel is visible (force reflow in odd cases)
  panel.style.display = 'flex';
}

function closePanel() {
  panel.classList.remove('open');
  panel.setAttribute('aria-hidden', 'true');
}

// syncing the Panel
function syncPanelToShape() {
  if (!selected) return;
  
  propType.value = selected.type;
  propFill.value = selected.opts.fill;
  propBorder.value = selected.opts.border;
  propThickness.value = selected.opts.thickness;
  propOpacity.value = selected.opts.opacity;
  propOpacityVal.innerText = selected.opts.opacity.toFixed(2);
  propRounded.checked = !!selected.rounded;
  propX.value = Math.round(selected.x);
  propY.value = Math.round(selected.y);

  // for rectangle
  if (selected.type === 'rectangle') {
    propW.value = Math.round(selected.w);
    propH.value = Math.round(selected.h);
    document.getElementById('sizeRow').style.display = '';
    document.getElementById('sizeRowH').style.display = '';
  } else { // for circle
    const r = Math.round(Math.max(0, Math.sqrt(selected.w*selected.w + selected.h*selected.h)));
    propW.value = r;
    propH.value = r;
    document.getElementById('sizeRow').style.display = '';
    document.getElementById('sizeRowH').style.display = '';
  }

  // text fields
  panelText.value = selected.text || "";
  panelTextSize.value = selected.textSize || 16;
  panelTextColor.value = selected.textColor || "#000000";
}

// apply shape properties
function applyPanelToShape(live = true) {
  if (!selected) return;
  selected.opts.fill = propFill.value;
  selected.opts.border = propBorder.value;
  selected.opts.thickness = +propThickness.value;
  selected.opts.opacity = +propOpacity.value;

  if (selected.type === 'rectangle') {
    selected.rounded = propRounded.checked;
    if (selected.rounded) selected.radius = Math.max(0, Math.min(Math.abs(+propW.value), Math.abs(+propH.value)) * 0.1);
    selected.x = +propX.value;
    selected.y = +propY.value;
    selected.w = +propW.value;
    selected.h = +propH.value;
  } else {
    const r = Math.max(0, +propW.value || +propH.value);
    selected.w = r; selected.h = r;
    selected.x = +propX.value;
    selected.y = +propY.value;
  }

  // text
  selected.text = panelText.value;
  selected.textSize = +panelTextSize.value;
  selected.textColor = panelTextColor.value;

  if (live) redraw();
}

// live updates from panel
propFill.addEventListener('input', () => { if(selected){ selected.opts.fill = propFill.value; redraw(); }});
propBorder.addEventListener('change', () => { if(selected){ selected.opts.border = propBorder.value; redraw(); }});
propThickness.addEventListener('input', () => { if(selected){ selected.opts.thickness = +propThickness.value; redraw(); }});
propOpacity.addEventListener('input', () => { if(selected){ selected.opts.opacity = +propOpacity.value; propOpacityVal.innerText = (+propOpacity.value).toFixed(2); redraw(); }});

// rounded corners
propRounded.addEventListener('change', () => { 
	if(selected && selected.type === 'rectangle'){ 
		selected.rounded = propRounded.checked; 
		if(selected.rounded) 
			selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1); 
			redraw(); 
	}
});

[propX, propY].forEach(inp => inp.addEventListener('input', () => { if(selected){ selected.x = +propX.value; selected.y = +propY.value; redraw(); }}));
propW.addEventListener('input', () => { if(!selected) return; if(selected.type === 'rectangle'){ selected.w = +propW.value; if(selected.rounded) selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1); } else { selected.w = +propW.value; selected.h = +propW.value; } redraw(); });
propH.addEventListener('input', () => { if(!selected) return; if(selected.type === 'rectangle'){ selected.h = +propH.value; if(selected.rounded) selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1); } else { const r = +propH.value; selected.w = r; selected.h = r; } redraw(); });

propApply.addEventListener('click', () => { applyPanelToShape(false); closePanel(); });
propReset.addEventListener('click', () => { syncPanelToShape(); });

panelClose.addEventListener('click', closePanel);

/* -------------------- Pointer Events -------------------- */
// when mouse click
canvas.addEventListener('pointerdown', (ev) => {
  ev.preventDefault();
  canvas.setPointerCapture(ev.pointerId);
  
  const pos = screenToCanvas(ev);

  activeHandle = null;
  isResizing = false;

  // check if click hits a resize handle -> start resizing
  if (selected) {
    const hn = selected.handleAt(pos.x, pos.y);
    if (hn) {
      activeHandle = hn;
      isResizing = true;
      startX = pos.x; startY = pos.y;
      return;
    }
  }

  // check if click hits a shape → select + drag
  selected = null;
  for (let i = shapes.length - 1; i >= 0; i--) {
    if (shapes[i].contains(pos.x, pos.y)) {
      selected = shapes[i];
      isDragging = true;
      dragOffsetX = pos.x - selected.x;
      dragOffsetY = pos.y - selected.y;
	  
      // open panel for this shape
      openPanelForShape(selected);
      redraw();
      return;
    }
  }

  // start drawing a new shape
  isDrawing = true;
  startX = pos.x; startY = pos.y;
  tempShape = null;
  
  // when starting to draw, close panel (avoid overlap)
  closePanel();
});

// when mouse is moving
canvas.addEventListener('pointermove', (ev) => {
  const pos = screenToCanvas(ev);
  
  // for resizing
  if (isResizing && selected && activeHandle) {
    resizeShape(selected, activeHandle, pos.x, pos.y);
    syncPanelToShape();
    redraw();
    return;
  }

  // for dragging
  if (isDragging && selected) {
    selected.x = pos.x - dragOffsetX;
    selected.y = pos.y - dragOffsetY;
    syncPanelToShape();
    redraw();
    return;
  }

  // for drawing
  if (isDrawing) {
	// drawing a rectangle
    if (shapeType.value === 'rectangle') {
      const x = Math.min(startX, pos.x);
      const y = Math.min(startY, pos.y);
      const w = Math.abs(pos.x - startX);
      const h = Math.abs(pos.y - startY);
      tempShape = new Shape('rectangle', x, y, w, h, {
        //border: borderType.value,
        //fill: fillColor.value,
        //thickness: +thickness.value,
        //opacity: +opacity.value
        //rounded: willBeRounded
      });
    } else { // drawing a circle
      const dx = pos.x - startX;
      const dy = pos.y - startY;
      const r = Math.max(0, Math.sqrt(dx*dx + dy*dy));
      tempShape = new Shape('circle', startX, startY, r, r, {
        //border: borderType.value,
        //fill: fillColor.value,
        //thickness: +thickness.value,
        //opacity: +opacity.value
      });
    }
    redraw();
    return;
  }

  // update cursor
  let cursor = 'crosshair';
  if (selected) {
    if (selected.handleAt(pos.x, pos.y)) cursor = 'nwse-resize';
    else if (selected.contains(pos.x,pos.y)) cursor = 'grab';
  } else {
    for (let i = shapes.length - 1; i >= 0; i--) {
      if (shapes[i].contains(pos.x,pos.y)) { cursor = 'pointer'; break; }
    }
  }
  canvas.style.cursor = cursor;
});

// when mouse is up
canvas.addEventListener('pointerup', (ev) => {
  ev.preventDefault();
  canvas.releasePointerCapture(ev.pointerId);
  const pos = screenToCanvas(ev);

  // for resizing
  if (isResizing) {
    isResizing = false;
    activeHandle = null;
    syncPanelToShape();
    redraw();
    return;
  }

  // for dragging
  if (isDragging) {
    isDragging = false;
    syncPanelToShape();
    redraw();
    return;
  }

  // for drawing
  if (isDrawing && tempShape) {
    if ((tempShape.type === 'rectangle' && tempShape.w > 4 && tempShape.h > 4) ||
        (tempShape.type === 'circle' && Math.sqrt(tempShape.w*tempShape.w + tempShape.h*tempShape.h) > 4)) {

      shapes.push(tempShape);
      selected = tempShape;
	  
      // open panel for new shape
      openPanelForShape(selected);
    }
    tempShape = null;
  }

  isDrawing = false;
  redraw();
});

canvas.addEventListener('pointercancel', (ev) => {
  if (isDrawing) { isDrawing = false; tempShape = null; redraw(); }
  if (isDragging) isDragging = false;
  if (isResizing) { isResizing = false; activeHandle = null; }
});

clearBtn.addEventListener('click', () => {
  shapes = [];
  selected = null;
  tempShape = null;
  closePanel();
  redraw();
});

deleteBtn.addEventListener('click', () => {
  if (selected) { 
    shapes = shapes.filter(s => s !== selected); 
	selected = null; 
	closePanel(); 
	redraw(); 
  }
});

// when change position of text in a shape
document.querySelector("#textPosition").addEventListener("change", (e) => {
  if (!selected) return;
    selected.textPosition = e.target.value;
  redraw();
});

// when press delete key to delete a shape
document.addEventListener('keydown', (e) => {
  if (e.key === 'Delete' && selected) {
    shapes = shapes.filter(s => s !== selected);
    selected = null; closePanel(); redraw();
  }
});

// deselect on canvas click when clicking empty area (and close panel)
// or when ending drawing a shape
canvas.addEventListener('click', (ev) => {
  const pos = screenToCanvas(ev);
  let hit = false;
  
  // If we are editing text, finish it when the user clicks the canvas
  if (editingShape) {
    finishInlineEdit();
  }
	
  for (let i = shapes.length - 1; i >= 0; i--) { if (shapes[i].contains(pos.x,pos.y)) { hit = true; break; } }
  if (!hit) { selected = null; closePanel(); redraw(); }
});

// ESC to cancel editing
document.addEventListener("keydown", (e) => {
    if (!editingShape) return; // no editor open -> do nothing

    if (e.key === "Escape") {
        finishInlineEdit();
    }
});

// when double-left click
canvas.addEventListener('dblclick', (ev) => {
  const pos = screenToCanvas(ev);
  
  // find topmost shape
  let hit = null;
  for (let i = shapes.length - 1; i >= 0; i--) {
    if (shapes[i].contains(pos.x, pos.y)) { hit = shapes[i]; break; }
  }
  
  if (!hit) return;
  
  startInlineEdit(hit);
  
  selected = hit;
});

// when right-clicking the canvas then close editor
canvas.addEventListener("contextmenu", (e) => {
    if (editingShape) {
        e.preventDefault();   // prevent default context menu
        finishInlineEdit();
    }
});

/* -------------------- Toolbar text controls binding -------------------- */

// Panel text bindings
panelText.addEventListener('input', () => {
  if (selected) { 
    selected.text = panelText.value;
	redraw();
  }
});

panelTextSize.addEventListener('input', () => {
  if (selected) {
    selected.textSize = +panelTextSize.value;
	redraw();
  }
});

panelTextColor.addEventListener('input', () => {
  if (selected) {
    selected.textColor = panelTextColor.value;
	redraw();
  }
});

// save changes when user leaves input or presses Enter
textEditor.addEventListener("blur", finishInlineEdit);

textEditor.addEventListener("input", () => {
    autoResizeTextEditor();
});

// deselect when clicking outside panel will already close because canvas handles it
// close panel on Esc
document.addEventListener('keydown', (ev) => {

	// when right-clicking outside the canvas, close editor
	document.addEventListener("contextmenu", (e) => {
		if (!editingShape) return;

		// clicked inside the text editor → keep editing
		if (textEditor.contains(e.target)) return;

		// clicked on canvas → canvas handler above handles it
		if (e.target === canvas) return;

		// otherwise right-click outside → close editor
		e.preventDefault();
		finishInlineEdit();
	});

	// Save changes when user leaves input or presses Enter
	if (ev.key === 'Escape') { 
		closePanel();
		selected = null;
		redraw(); 
	}
});

/* -------------------- Drawing Helpers -------------------- */
// start text editing inside the shape
function startInlineEdit(shape) {
    editingShape = shape;

    textEditor.value = shape.text || "";
	
	textEditor.style.textAlign = "center";
	textEditor.style.background = "transparent";
	textEditor.style.border = "none";        // optional
	textEditor.style.outline = "none";       // optional

    textEditor.style.left = (shape.x + canvas.offsetLeft) + "px";
    textEditor.style.top = (shape.y + canvas.offsetTop) + "px";
    textEditor.style.width = shape.w + "px";
    textEditor.style.height = shape.h + "px";
	
	// NOT wrap, shape text can be longer than box
    textEditor.style.width = shape.w + "px";
    textEditor.style.height = shape.h + "px";

    // disable wrapping
    textEditor.style.whiteSpace = "nowrap";
    textEditor.style.overflow = "hidden";
	
	// center text
    textEditor.style.textAlign = "center";
    centerEditorText(shape);
	
    textEditor.style.display = "block";
    textEditor.focus();
    textEditor.select();
}

// rounded rect drawing
function drawRoundedOrPlainRect(ctx, x, y, w, h, radius) {
  const absW = Math.abs(w), absH = Math.abs(h);
  const r = Math.max(0, Math.min(radius || 0, Math.min(absW, absH) / 2));
  const x0 = w >= 0 ? x : x + w;
  const y0 = h >= 0 ? y : y + h;
  const W = absW, H = absH;

  if (!r) {
    ctx.beginPath();
    ctx.rect(x0, y0, W, H);
    ctx.fill();
    ctx.stroke();
    return;
  }

  ctx.beginPath();
  ctx.moveTo(x0 + r, y0);
  ctx.lineTo(x0 + W - r, y0);
  ctx.arcTo(x0 + W, y0, x0 + W, y0 + r, r);
  ctx.lineTo(x0 + W, y0 + H - r);
  ctx.arcTo(x0 + W, y0 + H, x0 + W - r, y0 + H, r);
  ctx.lineTo(x0 + r, y0 + H);
  ctx.arcTo(x0, y0 + H, x0, y0 + H - r, r);
  ctx.lineTo(x0, y0 + r);
  ctx.arcTo(x0, y0, x0 + r, y0, r);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

/*
clears the canvas and draw:
  1. All shapes
  2. Text inside shapes
  3. The temp shape (if drawing)
*/
function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  shapes.forEach(s => {
	s.draw(ctx, s === selected);
	renderText(ctx, s);
  });
  
  if (tempShape) tempShape.draw(ctx, false);
}

function screenToCanvas(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

/*
Resizing Shapes: uses 4 corners handles:
	tl = top-left
	tr = top-right
	bl = bottom-left
	br = bottom-right
*/
function resizeShape(shape, handle, mx, my) {

  // for rectangle
  if (shape.type === 'rectangle') {
    let x = shape.x, y = shape.y, w = shape.w, h = shape.h;
    const right = x + w;
    const bottom = y + h;

    if (handle === 'tl') {
      x = mx; y = my;
      w = right - mx;
      h = bottom - my;
    } else if (handle === 'tr') {
      y = my;
      w = mx - x;
      h = bottom - my;
    } else if (handle === 'bl') {
      x = mx;
      w = right - mx;
      h = my - y;
    } else if (handle === 'br') {
      w = mx - x;
      h = my - y;
    }

    if (w < 0) { x = x + w; w = Math.abs(w); }
    if (h < 0) { y = y + h; h = Math.abs(h); }

    shape.x = x; shape.y = y; shape.w = w; shape.h = h;

    if (shape.rounded) {
      shape.radius = Math.max(0, Math.min(shape.w, shape.h) * 0.1);
    }
  } else { // for circle
    const dx = mx - shape.x;
    const dy = my - shape.y;
    const r = Math.max(2, Math.sqrt(dx*dx + dy*dy));
    shape.w = r; shape.h = r;
  }
}

// saves the text before the textarea width resets
function finishInlineEdit() {
    if (!editingShape) return;
	
    // save exactly the text the user wrote (NO wrapping)
    editingShape.text = textEditor.value;

	// hide editor
	textEditor.style.display = "none";
    editingShape = null;
	
	// redraw canvas with properly wrapped text
    redraw();
}

// adjusts height and wigth
function autoResizeTextEditor() {
	textEditor.style.width = editingShape.w + "px"; // keep width locked
    textEditor.style.height = "auto"; // reset
    textEditor.style.height = (textEditor.scrollHeight) + "px"; // fit to content
}

/*
wraps text so it fits inside the shape width
all text handling + wrapping + alignment

Draws the text according to:
	Position (center, top, bottom, left, right)
	Color
	Font size
	Alignment inside the shape
*/
function renderText(ctx, shape) {
    if (!shape.text) return;

    const padding = 6;
    const lineHeight = 16;
	
    ctx.save();
    ctx.fillStyle = shape.textColor || "#000";
    ctx.font = `${shape.textSize || 16}px sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // split text into lines (no wrapping)
    const lines = shape.text.split("\n");
	
    let x = shape.x + shape.w / 2;
    let y = shape.y + shape.h / 2;

    switch (shape.textPosition) {
        case "top":
            //x = shape.x;
            y = shape.y - lineHeight * (lines.length) - padding;
            break;
        case "bottom":
            //x = shape.x;
            y = shape.y + shape.h + lineHeight + padding;
            break;
        case "left":
		    ctx.textAlign = "right"; // text ends at the border
			x = shape.x - padding;   // just outside the left border
            //x = shape.x - shape.w;
            //y = shape.y + lineHeight;
            break;
        case "right":
		    ctx.textAlign = "left";                 // text starts at the border
			x = shape.x + shape.w + padding;        // just outside the right border
            //x = shape.x + shape.w + padding+6;
            //y = shape.y + lineHeight;
            break;
        default:
            // center (default)
            break;
    }

    // draw all lines
    for (let line of lines) {
        ctx.fillText(line, x, y);
        y += lineHeight;
    }
	
    //ctx.fillText(shape.text, x, y);
    ctx.restore();
}

function updateShapePropertiesPanel(shape) {
    if (!shape) return;

    document.getElementById("shapeFill").value = shape.opts.fill;
    document.getElementById("shapeBorder").value = shape.opts.border;
    document.getElementById("shapeOpacity").value = shape.opts.opacity * 100;
    document.getElementById("textSize").value = shape.textSize;
    document.getElementById("textColor").value = shape.textColor;

    // sync text position dropdown
    document.getElementById("textPosition").value = shape.textPosition;
}

function centerEditorText(shape) {
    const approxOffset = (shape.h / 2) - 10;
    textEditor.style.paddingTop = approxOffset + "px";
}
</script>
</body>
</html>
